{"meta":{"title":"“Amy的博客”","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2022-04-09T15:19:04.000Z","updated":"2022-05-10T08:54:24.114Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-04-09T15:17:37.000Z","updated":"2022-05-10T08:54:24.114Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-04-09T15:05:24.000Z","updated":"2022-05-10T08:54:24.114Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"GET和POST","slug":"get和post","date":"2022-04-20T07:58:43.000Z","updated":"2022-05-10T08:54:24.098Z","comments":true,"path":"2022/04/20/get和post/","link":"","permalink":"http://example.com/2022/04/20/get%E5%92%8Cpost/","excerpt":"在客户机和服务器之间进行请求-响应时，两种最常被用到HTTP请求方法是：GET和 POST。","text":"在客户机和服务器之间进行请求-响应时，两种最常被用到HTTP请求方法是：GET和 POST。 GET方法通常是从指定的资源请求数据 GET可以将参数数据加到URL中，用户可以看到 GET请求可以被缓存，可以保留在浏览器历史记录中 GET请求可以被收藏为书签 GET请求不应中处理敏感数据时使用 GET请求有长度限制 GET请求通常用于取回数据 POST方法通常向指定资源传送数据 POST请求数据放在Request body中。 POST请求不会被缓存 POST请求不会保留在浏览器历史记录中 POST不能被收藏为书签 POST请求对数据长度没有要求 例如这里的登录接口，账号和密码是写在Request body中， GET和POST的区别 区别类型 GET POST 安全性 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分，在发送密码或其他敏感信息时绝不要使用 GET ！ POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中 后退/刷新 无害 数据重新提交，重新请求接口 书签 可收藏为书签 不可收藏 缓存 能被缓存 不能缓存 编码类型 ASCII SO10646 历史记录 参数可以保存着历史记录中 参数不能保存 数据长度限制 最长2048个字符 无限制","categories":[{"name":"网络协议","slug":"网络协议","permalink":"http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}],"tags":[{"name":"HTTP请求方法","slug":"HTTP请求方法","permalink":"http://example.com/tags/HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95/"}]},{"title":"浅识HTTP和HTTPS","slug":"HTTP和HTTPS","date":"2022-04-19T08:24:23.000Z","updated":"2022-05-10T08:54:24.083Z","comments":true,"path":"2022/04/19/HTTP和HTTPS/","link":"","permalink":"http://example.com/2022/04/19/HTTP%E5%92%8CHTTPS/","excerpt":"网络协议是计算机之间为了实现网络通信而达成的一种“约定”或者”规则“，有了这种”约定“，不同厂商的生产设备，以及不同操作系统组成的计算机之间，就可以实现通信","text":"网络协议是计算机之间为了实现网络通信而达成的一种“约定”或者”规则“，有了这种”约定“，不同厂商的生产设备，以及不同操作系统组成的计算机之间，就可以实现通信 前言访问http网站，如下图浏览器显示不安全 访问https网站，如下图显示是安全的 HTTP 超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议, 特点 无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作 基于请求和响应：基本的特性，由客户端发起请求，服务端响应 简单快速、灵活 通信使用明文、容易泄露秘密 请求和响应不会对通信方进行确认、无法保护数据的完整性 通信传输 客户端输入URL回车 DNS解析域名得到服务器的IP地址 报文从运用层传送到运输层，运输层通过TCP三次握手和服务器建立连接 客户端发送请求数据 服务器处理请求，并返回数据 通过TCP四次挥手断开连接 浏览器加载数据并显示页面 HTTPS HTTPS是身披SSL外壳的HTTP。 HTTPS依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密，同时保护交换数据的隐私与完整性。 PS:TLS是传输层加密协议，前身是SSL协议 特点 内容加密：采用混合加密技术，中间者无法直接查看明文内容 验证身份：通过证书认证客户端访问的是自己的服务器 保护数据完整性：防止传输的内容被中间人冒充或者篡改 通信传输 客户端输入URL回车 DNS解析域名得到服务器的IP地址 TCP 三次同步握手 客户端验证服务器数字证书 DH 算法协商对称加密算法的密钥、hash 算法的密钥 SSL 安全加密隧道协商完成 网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。 服务器处理请求，并加密返回数据 通过TCP四次挥手断开连接 浏览器加载数据并显示页面 实现原理 客户端发起HTTPS请求 服务器配置，采用HTTPS协议的服务器必须要有一套数字证书，这套证书其实就是一对公钥和私钥 服务器给客户端的传送证书信息，这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。 客户端解析证书，首先会验证公钥是否有效，证书对生成随机值进行加密 传送加密信息，这部分传送的是用证书加密后的随机值，服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 服务端解密信息，服务端用私钥解密后，得到了客户端传过来的随机值 传送加密后的信息，服务器用随机值（私钥）加密返回的数据 客户端解密信息，客户端用之前生成的私钥解密服务段传过来的信息， HTTP 与 HTTPS 区别 安全性：HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。 费用：使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。 响应速度：HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。 端口：http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。 耗费的服务器资源：HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。","categories":[{"name":"网络协议","slug":"网络协议","permalink":"http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}],"tags":[{"name":"HTTP和HTTPS","slug":"HTTP和HTTPS","permalink":"http://example.com/tags/HTTP%E5%92%8CHTTPS/"}]},{"title":"非关系型数据库Redis","slug":"redis","date":"2022-04-10T09:01:39.000Z","updated":"2022-05-10T10:23:51.568Z","comments":true,"path":"2022/04/10/redis/","link":"","permalink":"http://example.com/2022/04/10/redis/","excerpt":"Redis是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是非关系型数据库。 它支持丰富的数据类型，以内存作为数据存储介质，所以读写数据的效率极高。","text":"Redis是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是非关系型数据库。 它支持丰富的数据类型，以内存作为数据存储介质，所以读写数据的效率极高。 连接12redis-cli // 本地连接，默认-h为localhost, -p默认为3306redis-cli -h host -p port -a password //远程连接 从上面的连接命令来看redis中没有账号的说法 redis中没有表的概念 redis中的数据是以键值对的格式进行存储的 redis中的数据是存储到内存中的 redis在正常关闭或者重启（例如在linux服务器上systemctl命令关闭或者重启redis）的时候，会提前把数据（不包含密码）保存到一个文件中，然后当我们下次启动redis时候，再从文件中，把数据加载到内存中，非正常关闭Redis服务时（例如断电），数据丢失不会保存 内存的读写速度是硬盘的300倍以上 redis中的数据操作的速度是MySQL的300倍以上 redis一般用于软件的缓存数据进行存储 数据格式 String字符串 可以是字符串、整数或浮点数 对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作； List列表 一个链表，链表上的每个节点都包含一个字符串 对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素； Set集合 包含字符串的无序集合 字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等 Hash散列 包含键值对的无序散列表 包含方法有添加、获取、删除单个元素,特别适合存储对象 Zset有序集合 和散列一样，用于存储键值对 字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素 数据库的操作String字符串命令 简述 使用 GET 获取存储在给定键中的值 GET key_Name SET 设置存储在给定键中的值 SET key_name value DEL 删除存储在给定键中的值 DEL key_name INCR 将键存储的值加1 INCR key DECR 将键存储的值减1 DECR key INCRBY 将键存储的值加上整数 INCRBY key amount DECRBY 将键存储的值减去整数 DECRBY key amount 实战场景 缓存： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。 计数器：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。 session：常见方案spring session + redis实现session共享， List列表Redis中的List其实就是链表（Redis用双端链表实现List），相同的元素可以充分出现 命令 简述 使用 RPUSH 将给定值推入到列表右端 RPUSH key value LPUSH 将给定值推入到列表左端 LPUSH key value RPOP 从列表的右端弹出一个值，并返回被弹出的值 RPOP key LPOP 从列表的左端弹出一个值，并返回被弹出的值 LPOP key LRANGE 获取列表在给定范围上的所有值 LRANGE key 0 -1 LINDEX 通过索引获取列表中的元素。你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。 LINEX key index 使用列表的技巧 lpush+lpop=Stack(栈) lpush+rpop=Queue（队列） lpush+ltrim=Capped Collection（有限集合） lpush+brpop=Message Queue（消息队列） 实战场景 微博TimeLine: 有人发布微博，用lpush加入时间轴，展示新的列表信息。 **消息队 Set集合Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。 命令 简述 使用 SADD 向集合添加一个或多个成员 SADD key value SCARD 获取集合的成员数 SCARD key SMEMBERS 返回集合中的所有成员 SMEMBERS key SISMEMBER 判断 member 元素是否是集合 key 的成员 SISMEMBER key member 实战场景 标签（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。 点赞，或点踩，收藏等，可以放到set中实现 Hash散列/哈希Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。 命令 简述 使用 HSET 添加键值对 HSET hash-key sub-key1 value1 HGET 获取指定散列键的值 HGET hash-key key1 HGETALL 获取散列中包含的所有键值对 HGETALL hash-key HDEL 如果给定键存在于散列中，那么就移除这个键 HDEL hash-key sub-key1 实战场景 缓存： 能直观，相比string更节省空间，的维护缓存信息，如用户信息，视频信息等。 Zset 有序集合Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。 命令 简述 使用 ZADD 将一个带有给定分值的成员添加到有序集合里面 ZADD zset-key 178 member1 ZRANGE 根据元素在有序集合中所处的位置，从有序集合中获取多个元素 ZRANGE zset-key 0-1 withccores ZREM 如果给定元素成员存在于有序集合中，那么就移除这个元素 ZREM zset-key member1 **Keys * **：查看所有Key 实战场景 排行榜：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行 保存 save 安全 设置密码：config set requirepass 密码 （这里的密码上临时的密码，重启redis后会消失） 认证：auth 密码 redis的设置， redis配置文件：/etc/redis.conf bind: 绑定IP，作用和MySQL的账号设置中的主机作用一样，限制那个IP来连接redis，默认本机IP127.0.0.1，放开0.0.0.0 port：端口号，默认6379 dir：保存的数据文件的路径 dbfilename：保存数据的文件的名字 requirepass：密码 以上配置修改后，需要重启redis 参考文档： https://pdai.tech/md/db/nosql-redis/db-redis-data-types.html","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"}]},{"title":"关系型数据库MySQL","slug":"mysql","date":"2022-04-10T09:01:28.000Z","updated":"2022-05-10T08:54:24.114Z","comments":true,"path":"2022/04/10/mysql/","link":"","permalink":"http://example.com/2022/04/10/mysql/","excerpt":"MySQL是最流行的关系型数据库管理系统（RDMS Relational Database Management System），是开源的，目前属于Oracle旗下产品。","text":"MySQL是最流行的关系型数据库管理系统（RDMS Relational Database Management System），是开源的，目前属于Oracle旗下产品。 数据库 数据库(Database)是按照数据结构来组织，存储和管理数据的仓库。 表（Table）是数据的矩阵，在一个数据库中的表看起来像一个简单的Excel表格。 主键（Primary key）主键是唯一的，一个数据表中只能包含一个主键，可以使用主键来查询数据。 安装在Windows上安装MySQL 下载安装包 将安装包解压到本地文件夹 把MySQL里面的bin目录配置到环境变量中 检查环境变量是否配置成功 打开cmd，输入mysql -V，出现MySQL的版本信息 通过命令安装数据库的服务 使用管理员身份打开cmd 123mysql -install -- 安装数据库的服务mysqld --initialize-insecure -- 对数据库进行初始化net start mysql -- 启动数据库 连接数据库 1mysql -h IP地址 -u 用户名 -p 按回车确认, 如果安装正确且 MySQL 正在运行, 会得到以下响应: 1Enter password: 若密码存在, 输入密码登录, 不存在则直接按回车登录。登录成功后你将会看到 Welcome to the MySQL monitor… 的提示语。 然后命令提示符会一直以 mysql&gt; 加一个闪烁的光标等待命令的输入, 输入 exit 或 quit 退出登录。 选择要操作的Mysql数据库，使用该命令后所有Mysql命令都只针对该数据库. 注意：命令要以英文“;”结尾。 1234567891011mysql&gt; use RUNOOB; Database changedmysql&gt; show databases;mysql&gt; show tables;mysql&gt; SHOW COLUMNS FROM runoob_tbl;-- 显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。mysql&gt; SHOW INDEX FROM runoob_tbl; -- 显示数据表的详细索引信息，包括PRIMARY KEY（主键）。mysql&gt; SHOW TABLE STATUS FROM RUNOOB; # 显示数据库 RUNOOB 中所有表的信息mysql&gt; SHOW TABLE STATUS from RUNOOB LIKE &#x27;runoob%&#x27;; # 表名以runoob开头的表的信息mysql&gt; SHOW TABLE STATUS from RUNOOB LIKE &#x27;runoob%&#x27;\\G; # 加上 \\G，查询结果按列打印mysql&gt; exit // -- 退出 mysql&gt; 命令提示窗口可以使用 exit 命令，Bye 数据库的管理 查看数据库 1show databases; 新建数据库 12create database 数据库的名字; create database 数据库的名字 default charset 字符集; -- （字符集，UTF8，UTF8mb4多一些生僻字） 修改数据库 1create database 数据库的名字 default charset 字符集; -- 数据库的名字不能修改，可以改字符集 删除数据库 1drop database 数据库的名字; 选择数据库 use 数据库名 1use 数据库的名字; 命名规则 库，表，字段全部采用小写，不要使用驼峰式命名 避免用保留字，例如index，desc等 只能使用英文字母，数字，下划线，并以英文字母开头。 表的管理 查看表 1show tables; 新建表 1create table 表名(字段属性1，字段属性2); 删除表 1drop table 表名; 修改表 12345alter table 表名; -- 修改表名alter table 表名 add 字段名，字段属性; -- 新增字段alter table 表名 drop 字段名; -- 删除字段名alter table 表名 modify 字段名 字段属性; -- 修改字段属性alter table 表名 change 老字段名 新字段名; -- 修改字段名 数据库的操作 增 1insert into 表名(字段1,字段2)values(值1,值2); 删 12delete from 表名;delete from 表名 where 查询条件 改 12update 表名 set 字段1=值,字段2=值;update 表名 set 字段1=值,字段2=值 where 查询条件; 查 123select * from 表名select 字段1,字段2 from 表名select * from where 查询条件1 and 查询条件2 多表联查 根据表的关系把两张表或者更多的表，结合起来一起查询 12select * from 表1 join 表2 on 表的关系;select * from 表1 join 表2 on 表的关系 where 查询条件 and 查询条件2; 关联的类型 内关联 join=inner join 外关联 左关联 left join 右关联 right join 嵌套查询 1select * from (select语句)表名; 统计-聚合函数 count（）计数，count对单独的字段进行计数的时候，胡忽略掉Null，所以为了避免这种情况，一般我们都不会对某个单独的字段计数，除非是有这个要求，一般我们都用count（*） sum（）求和 avg（）平均值，在平均值计算的时候，不会计算Null的行 min（）最小值 max（）最大值 分组 如果分了组，那么在select后面就只能写聚合函数，不能写单独的字段，不过，分组用的这个字段可以写 12select Count（*）,avg(数值字段) from 表名Group by 字段名; 别名，取外号的意思 字段别名 1select 字段 as A from 表名; -- 因为mysql语言运行的顺序，Where后不可以用字段的别名，表的别名可以用 表别名 1select * from 表名 A; -- A为别名 排序 12select * form 表名 where 查询条件order by 字段名 ASC/DESC; -- ASC为正向排序，DESC为倒叙，注意默认就是正向排序 限制查询显示的数量 12select * from 表名 Alimit x,y -- X的作用是从第几条开始显示，y的作用是一共显示几条，Limit y，这种是x默认为0 去重 1select distinct 字段名 from 表名 A case语句 条件判断语句 根据字段的不同情况显示不同的内容 12345select case when 条件 then 结果 end, 字段名 * from 表名 复制表 123create table 表名（select 语句）;-- 作用就是把select语句出来的虚拟表存到这个新创建的表里create temporary table 表名(select语句);-- 临时表 在数据库列表是是看不到的insert into 表1(字段名)select 语句; -- 字段名需要对应上,这里是批量将select出来的数据加入到表1 语法 数据类型 数据类型 含义 char(n),character(n) 长度为n的定长字符串 varchar(n),charactervarying(n) 最大长度为n的变长字符串 float（n） 可选精度的浮点数 date 日期，包括年，月，日，格式为（YYYY-MM-DD） Time 时间，包括一日的时，分，秒，格式为HH:MM:SS int,integer 长整型（4字节） smallint 短整型（2字节） bigint 大整数（8字节） 数值判断 =，!=, &gt; , &gt;=, &lt;, &lt;= is 判断是不是空 12xx is nullxx is not null like 语法 LIKE 通常与 % 一同使用，“张%”，“%美丽”，“%美%” 123SELECT field1, field2,...fieldN FROM table_nameWHERE field1 LIKE = &#x27;张%&#x27; in 语法-支持数字，字符串，等类型 判断在不在列表中 123WHERE column IN (1,2,...)WHERE column NOT IN (“a”,“ab”,...)WHERE column NOT IN (“上海”,“武汉”,...) in子查询 1SELECT * FROM article WHERE uid IN(SELECT uid FROM user WHERE status=0) order by 使用 ASC（升序） 或 DESC （降序）关键字来设置查询结果，默认情况下，它是按升排列。 12SELECT field1, field2,...fieldN table_name1, table_name2...ORDER BY field1, [field2...] [ASC [DESC]] **between X and Y ** 判断某个值是否在某个区间（闭区间） 12xx between 1 and 10;xx not between 1 and 10; sql的逻辑连接词 and 并且，or 或者，and not 并且不，or not 或者不 sql语句的结构顺序 select-&gt; from-&gt;join..on..-&gt;where..-&gt;group by..-&gt;having..-&gt;oreder by..-&gt;limit sql语句的运行顺序 from-&gt;join..on..-&gt;where..-&gt;group by..-&gt;as-&gt;having-&gt;select-&gt;distinct-&gt;oreder by-&gt;limit. Having和Where where与having都是用来筛选的 where在分组之前应用，having分组之后应用当一个查询包含了where条件和聚合函数，先执行条件过滤，再进行聚合函数，如： 1SELECT SUM(score) FROM sc WHERE score &gt; 60 //先过滤出score&gt;60的记录，再进行SUM求和 having在聚合之后进行过滤，having在分组的时候会用，对分组结果进行过滤，通常分组里面包含聚合函数，如： 1SELECT sid,AVG(score) FROM sc GROUP BY sid HAVING AVG(score) &gt;60 如果having中包含多个条件，这些条件将通过AND、OR或NOT连接在一起，如： 1SELECT sid,cid,AVG(score) FROM sc GROUP BY sid HAVING AVG(score) &gt;60 AND cid != &#x27;001&#x27; ; 表的类型 真实表 虚拟表 临时表 临时表的用法和真实表的用法一模一样 临时表是看不到的，但是你知道表名还是可以正常的操作 如果断开了数据库的连接，临时表会自动销毁 1create temporary table 表名(); 事务1234begin; -- 开始事务commit; -- 提交事务rollback; -- 回滚事务source sql文件; -- 运行sql文件 NavicatNavicate是一个操作数据库的工具 连接 IP地址：数据库所在地址的IP 端口：数据库的端口号，默认3306 账号：数据库的账号，默认账号是root 密码：数据库账号对应的密码，刚安装好默认是没有密码的。 事务 通过事务主管数据库的功能就可以避免我们在操作【数据】的时候失误 回滚事务：回滚不是回滚一步，是回滚到开始事务之前的一个状态 提交事务：确认操作无误，就可以提交事务了，提交后就不能回滚了 备份 保存为sql文件（结构，结构和数据） 运行sql文件，就可以还原之前的备份。 设置密码 设置密码 root@localhost 是指root这个账号只能在localhost这个IP下登录，这里的IP是相对于数据库所在的服务器的IP而言的 root@% 是指这个root账号可以在任何IP下来登录","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"}]},{"title":"操作系统Linux","slug":"linux","date":"2022-04-10T08:58:01.000Z","updated":"2022-05-10T08:54:24.114Z","comments":true,"path":"2022/04/10/linux/","link":"","permalink":"http://example.com/2022/04/10/linux/","excerpt":"Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统, 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件，Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统","text":"Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统, 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件，Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统 Xshell和Xftp远程连接服务器IP: 服务器的公网IP 端口：22 账号：root (服务器系统账号) 密码：（服务器系统密码，自己设置） 工具Xshell Xftp 基本命令查看文件夹ll 文件夹的详细信息可以看到 ls 查看文件的名字 创建文件，文件夹touch 文件的名字 mkdir 文件夹的名字 复制/移动cp 文件 目标地址 cp -r 文件 目标地址 mv 文件/文件夹 目标地址 删除rm 文件 – 删除文件并确认 rm -f 文件 – 删除文件 rm -r 文件夹 – 删除文件夹并确认 rm -rf 任意东西 – 删除 路径查看当前所在的路径 pwd 绝对路径 相对路径：相对于目前所在的路径 路径的符号/ 根目录 （根目录下的文件都是系统文件） .. 上级目录 . 当前目录 ~ 可以理解成桌面文件夹，如果账号是root，用户目录就是/root, 如果账号是zhangsan，那么用户的目录就是/home/zhangsan - 上一次打开的目录 cd 路径 进入某个路径 linux的文件属性- 开头 表示是文件 d 开头 表示是文件夹 x 表示这个东西可执行 r 表示这个东西可读 w 表示这个东西可以写 文件的读写vi 文件 进入文件 i/a/insert 进入编辑模式 esc 退出编辑模式 :q 退出 :w 保存 :wq 保存并退出 :q! 不保存退出 cat 一次性读取文件的内容 more 逐步读取 tail -f 动态读取，一般去读取软件的日志 tail -f -n 100 读取倒数100条数据 linux上的搜索grep 文件内的搜索，需要和其他的有输出的命令组合使用，例如ll，cat，more，yum list 例如：cat 文件名|grep 搜索的内容 find 文件的搜索 find 搜索的范围 -name 文件的名字 例如：find / -name 日记本 系统相关的命令netstat -ntlp 查看已经使用了的端口号 ps -ef 查看正在运行的软件进程 kill -9 pid 强制杀死pid对应的程序的进程 systemctl 管理软件的服务的，例如：systemctl start nginx, 同等与windows上的net 1234systemctl start redis -- 启动Redis服务systemctl stop redis -- 关闭redis服务systemctl restart redis. -- 重启redis服务systemctl status redis -- 查看redis服务运行状态 12mysql -h 主机地址 -u 用户名 -p -- 回车后输入数据库密码service mysqld status -- 查看MySQL服务的状态 linux上软件的安装常用的软件：nginx，redis，unzip yum 在线安装，类似于在手机上的应用商城安装软件 yum list 查看可以安装的软件的列表 yum install 软件名 安装软件 yum remove 软件名 卸载软件 12yum install redis -- 安装redisyum remove redis -- 卸载redis 离线安装 压缩包的安装 解压 tar zxvf *.tar.gz //解压以tar.gz后缀压缩包 tar xvf *.tar //解压以tar后缀的压缩包 tar xvf *.zip //解压以zip后缀的压缩包 unzip *.zip //解压以zip后缀的压缩包 安装包的安装 rpm -qa // 查看服务器上已经安装了的软件，其中不包括用压缩包安装的 rpm -ivh 安装包的名字 // 安装软件 rpm -e –nodeps 软件的名字 // 强制卸载软件","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"性能测试工具Jmeter","slug":"jmeter","date":"2022-04-10T06:40:43.000Z","updated":"2022-05-10T08:54:24.098Z","comments":true,"path":"2022/04/10/jmeter/","link":"","permalink":"http://example.com/2022/04/10/jmeter/","excerpt":"Apache JMeter是用来负载功能测试和性能测试的纯Java开源软件, 可以使用JMeter对web应用或各种各样服务的性能进行分析和度量, JMeter最初被设计用于Web应用或FTP应用测试，现在扩展到功能测试、数据库服务器测试等。","text":"Apache JMeter是用来负载功能测试和性能测试的纯Java开源软件, 可以使用JMeter对web应用或各种各样服务的性能进行分析和度量, JMeter最初被设计用于Web应用或FTP应用测试，现在扩展到功能测试、数据库服务器测试等。 常见的性能测试工具有LoadRunner,Jmeter，是Java开发的，都是免费开源的， 运行环境Java，所以安装Jmeter前必须要要安装Java 启动进入Jmeter项目文件的bin目录，双击jmeter.bat启动 打开时有两个窗口，Jmeter的命令窗口和Jmeter的图形操作界面，不可以关闭命令窗口 根目录说明 backup目录 ：脚本备份目录，里面的文件都是以.jmx后缀结尾 bin目录：可执行文件 Jmeter.bat: 是启动jmeter的主脚本 Jmeter-server.bar:是用来实现联机负载 Jmeter.properties: 是jmeter主要的配置文件，查过80%的配置项都是通过这个文件实现（PS：修改配置文件后，要重启Jmeter才能生效） 在#language=en下面插入一行language=zh_CN 重启Jmeter后界面默认显示中文 在\\#sampleresult.default.encoding=ISO-8859-1下插入一行sampleresult.default.encoding=utf-8,解决Jmeter中控制台无法识别中文导致乱码的问题。 编写项目测试脚本Jmeter做接口测试 业务流程串联测试 单个接口测试 添加线程组 测试用例，性能测试中也叫场景，一个测试计划中可以包含多个线程组 配置线程组参数 线程数：虚拟用户数 Ramp-Up时间（秒）：设置的虚拟用户数需要多长时间全部启动，如果线程数为100，准备时长为5，那么需要5秒钟启动100个线程，也就是每秒钟启动20个线程。 相当于每秒模拟20个用户进行访问，设置为零我理解为并发访问。 循环次数：如果线程数为100，循环次数为100。那么总请求数为100*100=10000 。如果勾选了“永远”，那么所有线程会一直发送请求，直到选择停止运行脚本。 添加测试接口 协议：向目标服务器发送HTTP请求协议，可以是HTTP或HTTPS，默认为HTTP。 服务器名称或IP ：HTTP请求发送的目标服务器名称或IP。 端口号：目标服务器的端口号，默认值为80 方法：发送HTTP请求的方法，可用方法包括GET、POST等。 路径：目标URL路径（URL中去掉服务器地址、端口及参数后剩余部分）。 内容编码：编码方式，默认为ISO-8859-1编码， 参数：同请求一起发送参数 ，在请求中发送的URL参数，例如GET请求时，有时会需要填写 消息体数据：一般是POST请求中，请求参数写在这里（Json格式） 添加查看结果数 查看结果 取样器结果，http状态码 请求：请求类型/地址/参数/请求头 响应数据：服务器返回的数据，有搜索功能，可以搜索你需要查看的返回值 根据结果树排查出错原因 观察脚本是否报错 查看状态码判断问题 请求信息是否正确 返回值查看结果 HTTP信息头管理 Json断言 断言：实际结果和预期结果做对比 断言原理 ：工具自动判断http状态码，如果状态码&gt;400,直接报错，如果http状态码正常，再根据自定义的断言进行判断。 配置Json断言具体信息 $ 代表Json对象，例如$.code, Expected Value: 预期结果，例如1， 这里的意思就是，预期后台反馈Json对象中Code值为1. 断言结果 下列是预期结果和实际结果一致 下列是预期结果和实际结果不一致 关联上一个接口的返回值给下一个接口用 Json提取器 在第二个接口中引用变量gtoken 参数化 准备好参数文件，一般以txt结尾 添加配置原件-CSV数据文件设置 引用变量 运行结束后的结果如下，产生了三个测试用例。 添加聚合报告 性能测试聚合报告 为了测试出效果，我这里模拟30个用户并发访问获取数据，循环5次，线程组数据修改如下： 分析测试报告 聚合报告参数详解 **样本(Samples)**：请求数——表示这次测试中一共发出了多少个请求，我这里模拟了30个用户循环5次也就为30*5=150。 平均值(Average)：平均响应时间(单位:ms)。默认是单个Request的平均响应时间， **中位数(Median)**：也就是 50％ 用户的响应时间。 95% Line：95％ 用户的响应时间，建议取这个值。 **最小值(Min)**：最小响应时间。 **最大值(Max)**：最大响应时间。 失败率（Error）：错误率——错误请求数/请求总数。 **吞吐量(Throughput)**：服务器每秒处理的请求量，相同条件下吞吐量越大，服务器的性能越强， 接收 KB/Sec：每秒从服务器端接收到的数据量， 发送 KB/Sec：每秒向服务器发送的数据量， 性能指标 响应时间：建议取95%Line； 失败率（Error） 吞吐量 服务器的CPU使用率，这样要在服务器上或者服务器管理端去看 性能指标量化响应时间：每个行业有不同的要求，每个项目也有不同的标准，如果没有任何参考，可以以258原则参考，2s-优秀，2~5s-良，5-8s-可接受，超过8s，不接受 前台标准：一般互联网行业，2000qps下，失败率不超过0.05%，95%line为不超过300ms可接受；非互联网行业，2000qps下，失败率不超过0.1%，95%line为不超过1.5s可接受 并发 并发用户数，服务器同时刻接收到的用户量 并发请求数（QPS）：服务器同时刻接收到的请求数量 设置并发 设置线程数 ​ 这里设置的300个用户数，10秒内启动完这些用户（也就是20秒内用户数从0增加为300，每秒增加30个用户），持续5分钟（这里前 10秒用户数是一直递增的，10秒后用户数保持300，） 集合点（瞬时并发比较高的业务，时间短，例如双11） 拦截50个人一组一起并发调用（也就是等到用户凑够50个人时，才一起同时刻调用），如果等了3000ms（3s）没有凑高50人，那就有多少人，用多少，不强求。","categories":[{"name":"测试工具","slug":"测试工具","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Jmeter","slug":"Jmeter","permalink":"http://example.com/tags/Jmeter/"}]},{"title":"接口测试工具Postman","slug":"postman","date":"2022-04-10T06:40:12.000Z","updated":"2022-05-10T12:41:53.072Z","comments":true,"path":"2022/04/10/postman/","link":"","permalink":"http://example.com/2022/04/10/postman/","excerpt":"Postman是一个独立的软件测试API(应用程序编程接口)平台，用于构建，测试，设计，修改和记录API。这是一个简单的图形用户界面，用于发送和查看HTTP请求和响应。","text":"Postman是一个独立的软件测试API(应用程序编程接口)平台，用于构建，测试，设计，修改和记录API。这是一个简单的图形用户界面，用于发送和查看HTTP请求和响应。 JsonJson的文件类型是.json Json语法规则 数据在key/value对中 数据由逗号隔开 大括号{}保存对象 中括号[]保存数组，数组可以包含多个对象 Json值 数字（整数或者浮点） 字符串（在双括号中） 逻辑值（true或者false） 数组（在中括号中） null 可以用for-in来访问对象和数组12345678var myObj = &#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:null &#125;;var x;x=myobj.name //用.来访问对象myobj.alexa=&quot;google&quot;; //修改对象的值delete myobj.site; //删除对象属性for (x in myObj) &#123; x= x + &quot;&lt;br&gt;&quot;;&#125; //循环访问对象 也可以用索引值来访问数组1234567var site=[&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;] ;x=site[0];site[0]=&quot;Github&quot; //修改数组值delete site[0] //删除数组元素for (i in site) &#123; x= site[i] + &quot;&lt;br&gt;&quot;;&#125; //循环访问数组 Json.parse()转换服务器返回的数据，从字符串转换为JavaScript对象，服务器返回的数据一般是字符串 1JSON.parse(text[, reviver]) //test必需，一个有效的Json字符串；reviver可选，一个转换结果的函数， 将为对象的每个成员调用此函数。 JSON.stringify()可以把向服务器发送的数据，从JavaScript 对象转换为字符串，在向服务器发送数据时一般是字符串 1JSON.stringify(value[, replacer[, space]]) Jason 使用最常用的用法是，从web服务器上读取Json数据，将Json数据转换为JavaScript对象，然后在网页中使用该数据 状态码用来判断接口状态 200+ 请求成功 300+ 重定向 400+ 请求出错 500+ 服务器异常 状态码 解释 200 请求成功 301 请求的资源被永久的移动到新的url，浏览器会自动定向到新的URL，返回的信息包含新的url 400 客户端请求的参数格式错误（例如请求要求用Json格式，却用Text格式），服务端无法理解 404 请求的资源找不到 403 禁止访问，资源是保密的 405 请求的方法不允许（例如应该用post，却用get请求） 500 服务器内部错误，无法完成请求 502 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 504 充当网关或代理的服务器，未及时从远端服务器获取请求 接口的结构 请求 请求头Headers Json（Content-Type：application/json）这是指定参数的格式 ….. 请求类型/方法 get post …… 请求参数body raw (90%使用的都是json，还有text和网页格式的html, xml ) form-data：表格格式 响应 响应数据 返回值{code，message，data} 响应头 状态码（200，402……） Postman中的全局变量，环境变量，集合变量在Postman中设置【变量】，作用域从大到小为 全局 &gt; 集合 &gt; 环境，当三个变量形式同时作用于一个 API 测试条时，Postman 会优先使用最小作用域变量。 全局变量 可应用到Postman的所有测试的API中 环境变量 可以理解为一组选项，当选中时才生效。 集合变量 是针对集合（collections）生效的 全局变量和环境变量操作下拉标记的2为环境变量，3为全局变量 集合变量操作 选中一个集合，点击集合标题右侧「…」选择编辑。 进入集合设置页，选择 Variables 设置集合变量 此时，整个集合下所有请求页，都应用了此集合变量 Postman Pre-request Script预请求脚本Pre-request scripts在API请求之前执行，我们可以临时更改请求的某些变量， 设置动态请求头Headers信息 设置动态请求参数body信息 常用的 Pre-request scripts12345678910111213141516171819pm.globals.get(&quot;key&quot;) //获取全局变量pm.environment.get(&quot;key&quot;); //获取环境变量pm.globals.unset(&quot;key&quot;); //清除全局变量pm.environment.unset(&quot;key&quot;); //清除环境变量//将数组储存到环境变量中var array = [1, 2, 3, 4];postman.setEnvironmentVariable(&quot;array&quot;, JSON.stringify(array)); //将嵌套对象储存到环境变量中var obj = &#123; a: [1, 2, 3, 4], b: &#123; c: &#x27;val&#x27; &#125; &#125;;postman.setEnvironmentVariable(&quot;obj&quot;, JSON.stringify(obj)); //从环境变量中获取数组对象var array = JSON.parse(postman.getEnvironmentVariable(&quot;array&quot;)); //从环境变量中获取嵌套对象/json对象var obj = JSON.parse(postman.getEnvironmentVariable(&quot;obj&quot;)); 举例说明：比如我们要在 header 中包含一个时间戳，我们可以这样操作 在 Pre-request scripts 中添加获取时间戳的代码 创建 Postman Tests 测试脚本 - Postman 断言功能 预置脚本在请求前生效，断言在请求后生效 如何在 Postman 中使用控制台Tests 测试脚本中加入 console.log 来显示我们需要在控制台显示的调用信息。","categories":[{"name":"测试工具","slug":"测试工具","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Postman","slug":"Postman","permalink":"http://example.com/tags/Postman/"}]},{"title":"我的博客之旅","slug":"我的Hexo博客之旅","date":"2022-04-09T15:29:13.000Z","updated":"2022-05-10T08:54:24.114Z","comments":true,"path":"2022/04/09/我的Hexo博客之旅/","link":"","permalink":"http://example.com/2022/04/09/%E6%88%91%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/","excerpt":"Hexo是一个快速，简介且高效的博客框架,Hexo使用Markdown解析文章，并生成静态页面。","text":"Hexo是一个快速，简介且高效的博客框架,Hexo使用Markdown解析文章，并生成静态页面。 安装需要的技术工具 Node.js Git 上述安装成功后，接下来安装Hexo,见如下命令 1$ npm install -g hexo-cli 安装完成后执行以下命令,Hexo会在指定文件夹下新建所需文件,在您的博客文件下，右键，打开git bash，初始化博客。 1$ hexo init 最后生成如下文件夹 上述只列出个别文件夹名，_posts内为我们所写的所有文档，_theme 存放从Git clone下来的主题，_config配置网站,package.json应用程序的信息,public是后面生成时出现的，别着急哈!!! :smile: 主题在这里找到你所喜欢的主题,然后根据主题路径克隆下来放在上述theme文件夹下，例如nexT主题。 1git clone https://github.com/iissnan/hexo-theme-nextthemes/next 配置_config.yml内配置 参数 描述 title 网站标题,例如，我的第一个博客 subtitle 网站副标题 description 网站描述，主要用于SEO，告诉搜索引擎一个关于您站点的简单描述 author 您的名字 language 网站使用的语言 timeZone 网站时区，Hexo默认使用您电脑的时区 theme 主题名称，例如nexT 现在可以运行你的网站了， 加油哈 ！！！:dog: 先生成，这时会新增上面提到的public文件夹 1$ hexo g 然后运行，就可以在浏览器看到初始博客了， 1$ hexo s // 启动服务预览 部署在你的github上新建respository 配置路径,如图，repo值为你建的仓库的路径。 安装hexo-deployer-git自动部署发布工具， 1$ npm install hexo-deployer-git --save 然后依次输入以下命令 123$ hexo clean //清除缓存 网页正常情况下可以忽略此条命令$ hexo g // 生成静态页面至public目录$ hexo d // 部署，将.deploy目录部署到GitHub 发布完成!!! 写作新建文件 1$ hexo new [layout] &lt;title&gt; layout 布局默认3种布局，post，page，draft，分别对应不同的布局。 布局 路径 post source/_posts page source draft source/_drafts 写完生成发布就OK了。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]}],"categories":[{"name":"网络协议","slug":"网络协议","permalink":"http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"测试工具","slug":"测试工具","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"},{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/categories/Hexo/"}],"tags":[{"name":"HTTP请求方法","slug":"HTTP请求方法","permalink":"http://example.com/tags/HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95/"},{"name":"HTTP和HTTPS","slug":"HTTP和HTTPS","permalink":"http://example.com/tags/HTTP%E5%92%8CHTTPS/"},{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"Jmeter","slug":"Jmeter","permalink":"http://example.com/tags/Jmeter/"},{"name":"Postman","slug":"Postman","permalink":"http://example.com/tags/Postman/"},{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]}